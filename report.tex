\documentclass[sigconf]{acmart}

\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}


%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[APE CS 598]
{APE CS 598}{Spring 2025}{Urbana, IL}

\begin{document}

\title{Java Chess Engine}

\author{Adam McNeil}
\email{adamwm4@illinois.edu}
\affiliation{%
  \country{University of Illinois Urbana-Champaign, Urbana, Illinois, USA}
}


\begin{abstract}
In this paper we highlight optimization done on a Java chess engine.
The goal of the optimization are to increase the depth that the engine is able to compute efficiently.
Though this does not necessarily make it better at playing chess since we are computing at a small depth increasing it will make the chess engine more accurate.
There are also other way to make the chess engine better they are not the focus of this paper.
\end{abstract}

\maketitle
Link to the engine: \url{https://github.com/adamMcneil/chess-engine}

Link to the bot: \url{https://github.com/adamMcneil/cheeky-koala-lichess-bot}
\section{Background}
This project was originally developer by me and friend in the summer of 2021.
We designed it in an object oriented way which was not always the most preformant.
This is the original file structure of the project:
\begin{verbatim}
Cheakykoala/
|-- Pieces/
|   |-- Bishop.java
|   |-- Empty.java
|   |-- King.java
|   |-- Knight.java
|   |-- Pawn.java
|   |-- Piece.java
|   |-- Queen.java
|   |-- Rook.java
|-- Board.java
|-- Color.java
|-- Main.java
|-- Move.java
|-- Position.java
|-- PromotionMove.java
\end{verbatim}
\texttt{Piece} is an abstract class that the other piece inherit from.
\texttt{Color} is an \texttt{Enum} with three values \texttt{w, b, g}.
These represent white, black, and gray respectively.
Gray is used for the Empty Piece.
Have a Empty Piece to represent a blank square does not seem very performance but surprisingly it does not make a huge impact on performance.
The \texttt{Position} class adds a lot of overhead to the program; all it does is wrap two integers together to represent the position.
It introduces a lot of unnecessary object allocation and functions call.
\texttt{PromotionMove} inherits from the \texttt{Move} class; this is probably not the best way to handle this and should be optimized.

\subsection{Gradle}
In the past I relied on the IntelliJ IDE for building the project.
Since the project was out of date it did not work when I dusted the project off.
So I decided to switch to Gradle for building the project.
This was a good decision because it offers a lot of different action out of the box like: running the application, running tests, and generating jar files.

\subsection{IntelliJ}
Since I am a student I have access to IntelliJ Ultimate.
IntelliJ Ultimate offer a lot of features that will be very helpful for performance engineering the application.
They have built in code coverage tool that will show what percentage of lines that are covered by your tests.
They also give you access to a profiling program that will generate a Flame Graph, Call Tree, Method List, Timeline, CPU Usage, and Events.
It also give me access to the debugger which will be helpful for debugging.

\subsection{Lichess}
I used an open source resource \cite{lichess-bot} to connect my chess engine to Lichess.
It uses the universal chess interface (UCI) \cite{uci} to talk to Lichess.
In order to use the program you only need to point the program to your chess engine executable and use a yaml config file to configure your chess engine.
It also allows you to use opening books, which is a set of games that the engine will play by default at the beginning of a game \cite{pgn}.

In order to turn the chess project into a executable.
I use Gradle to build the project in to a jar file and then use a bash script to execute the file.
This just runs the java interpreter.
We use the following simple script to run the program.
\begin{verbatim}
#!/bin/bash
java -cp chess-engine-1.0-SNAPSHOT.jar cheekykoala.Main
\end{verbatim}
In order to communicate with Lichess, must make your chess engine respond very simple inputs described in Table~\ref{tab:api}.

\begin{table*}[h]
    \centering
    \renewcommand{\arraystretch}{1.2}
    \setlength{\tabcolsep}{8pt}
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Input} & \textbf{Description} & \textbf{Output} \\
        \hline
        \texttt{uci} & Confirming that the engine is running uci. & \texttt{uciok} \\
        \hline
        \texttt{isready} & Confirming that the engine is ready. & \texttt{readyok} \\
        \hline
        \texttt{position <fen> moves <list of moves>} & Load the board position from the server & \\
        \hline
        \texttt{go wtime <n> btime <n> winc <n> binc <n>} & Output a move that you want to make. & bestmove (e2e4) \\
        \hline
        \texttt{quit} & \texttt{Quit the chess engine} & \\
        \hline
    \end{tabular}
    \caption{A description of the API that the chess engine needs to response to play on Lichess.}
    \label{tab:api}
\end{table*}


\section{Introduction}
A chess engine consists of a couple of basic parts.
\begin{enumerate}
    \item \textbf{Move Generation} – Responsible for determining all legal moves from a given board state.
    \item \textbf{Board Evaluation} – Assigns a score or value to a position to help judge its quality.
    \item \textbf{Search Algorithm} - Combines the other component to find the best move in any given state.
\end{enumerate}

\subsection{Move Generation}
This is relatively simple it just requires you to specify the rules of chess in a programming language.
This requires a lot of test and debugging to cover all of the corner cases (literally the corner cases).
However the structure of the data that you use in this case will affect how efficiently you can produce a list of legal moves. 

\subsection{Board Evaluation}
This in the most simple form is variable with four possible values.
\begin{itemize}
    \item Black in checkmate
    \item White in checkmate
    \item Stalemate
    \item None
\end{itemize}
However this is an unrealistic metrics because the search space is to massive to find a mate from stating position and the bot would see no way to win so it would play randomly.

The next obvious metric would be material advantage (this is simple who has better pieces on the board).
We assign values to each piece and make the black piece the negative value of the white pieces.
In this way we can have the player prefer positions were they have better pieces on the board and the other person has less players on the board.
This is a good heuristic for who is winning the game.

However this does not capture everything that chess players to determine which side is in better position.
Players also develop pieces this usually means moving piece toward the center of the board or having a good pawn structure.
In order to capture this we can use a table of values that offer a little benefit to piece in each of those positions.
Each Piece has a separate table of value that is used to determine the benefit of each Piece in a specific location on the board.
Intuitively this is because it is better to have your king in the back protected, and pawns it is good to have on the second to last row so that they are close to promoting.

\subsection{Move Search}
Since chess is a two player game it uses a mini-max algorithm to find the best move.
There are better explanation of this algorithm is online somewhere, but at a basic level the computer takes turns maximizing and minimizing the branching board state.
This simulate both player playing optimally and will allow the computer to compute the most optimal solution.

Now that we have a move generator and way to compare board we can use standard graph algorithms to search for the best move.
The most basic search would be a depth search.
However this is not optimal in chess because the player needs to move in real time.
It is hard to know how long the depth search will take.
Because of this it is hard to determine the what depth the bot should search for. 
Furthermore the search needs to complete before it finds a move.

The algorithm that is best for looking for moves in chess is iterative deepening.
It works by doing consecutive executions of a depth search.
This allows the bot to return the best move that is has found after it has reached some timeout.


\section{Related Works}
Stockfish \cite{stockfish} is the state of the art in chess engines today.
It has dominated the Top Chess Engine Championship for the past several years.
It is implemented with C++ and is open source.

The project uses a distributed testing frame work called Fishtest where people donate CPU time to play games against the release of Stockfish.
After playing bunch of game they determine if the change was better and should be keep \cite{stockwiki}.
Stockfish is trying to optimize winning games; this is not what we are trying to optimize in this paper.
This paper primarily focus on being able to compute a larger depth faster.

It uses bit boards to represent the state of the board \cite{stockwiki}.
Bit boards work by using a 64 bit array to store the states of the board.
A different bit board is used for each piece.
This board can be combined to generate moves.

One notable change to Stockfish happened in 2020 when efficiently updatable neural network (NNUE) to evaluate the board state \cite{chesswiki}.
This replaced the heuristics that are previously used to compare boards.





\section{Overview}
We perform a wide range of optimization on the chess engine.
However all the changes that we made can be categorized into three groups:
\begin{enumerate}
    \item Data Structure Changes
    \item Adding Parallelism
    \item Implementing Search Heuristics
\end{enumerate}

This type optimization included changing the way we represented the board.
The original optimization used a 2-D array however we found that a 1-D array was more efficient.
It reduced overhead by eliminating the Position class and allowed us to identify a position with just and integer.
We were also able to make all of the Piece class Singleton class by removing the position variable on the Piece class.

This type of graph search is highly parallelism because we can have multiple thread working on different portions of the tree.
The parallelism that we implement in this works by paralleling the base layer of the mini-max.
Effectively meaning that each of the moves at depth one are being computed in parallel.
Though this does increase the efficiency of the program be a lot.
This is not the best way to implement parallelism and lead to a lot of problems that will be discussed in the implementation.

We were able to also include some logic for 

There are also a lot more optimization/refactoring that cannot all be reported.
For example the static arrays was being reallocated in a loop while generating moves which was causing overhead.
We were also able the restructure if statement to break earlier.

\section{Implementation}
\subsection{Tests}
It is very important to run tests to verify that your application is correct after refactoring for performance.
To achieve this, I used a database of chess positions \cite{jones} and the number of legal moves at a certain depth to verify the accuracy of the chess engine.
Each of the individual tests are formed like the following json object. 
The test imports the fen \cite{fen} string and verifies that the number of nodes is the same at that depth of search.
\begin{verbatim}
  {
    "depth":1,
    "nodes":8,
    "fen":"r6r/1b2k1bq/8/8/7B/8/8/R3K2R b KQ - 3 2"
  }
\end{verbatim}
I also created similar tests that would test the piece that tested the piece individually that would make it easier to pin point bugs.
I am waiting to wright unit tests for the Board class until after I refactor it to use a 1-D array.

\subsection{Board Representation}
A large refactoring that will increase the efficiency of the program by a lot is representing the board with a 1-D array instead of a 2-D array.
This makes computing moves a little more tricky but it will result in being able to get rid of the \texttt{Position} class.
The \texttt{Position} class is creating a lot of unnecessary object allocations.
The class only contains an \texttt{int[]} with two elements.
By switching to a 1D array to represent the board we can represent a position on the board with just an \texttt{int}.
\begin{table}[H]
    \renewcommand{\arraystretch}{1.5}
    \setlength{\arrayrulewidth}{1pt}
    \setlength{\tabcolsep}{4pt}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
        \hline
        0,0  & 1,0  & 2,0  & 3,0  & 4,0  & 5,0  & 6,0  & 7,0  \\
        \hline
        0,1  & 1,1  & 2,1  & 3,1  & 4,1  & 5,1  & 6,1  & 7,1  \\
        \hline
        0,2  & 1,2  & 2,2  & 3,2  & 4,2  & 5,2  & 6,2  & 7,2  \\
        \hline
        0,3  & 1,3  & 2,3  & 3,3  & 4,3  & 5,3  & 6,3  & 7,3  \\
        \hline
        0,4  & 1,4  & 2,4  & 3,4  & 4,4  & 5,4  & 6,4  & 7,4  \\
        \hline
        0,5  & 1,5  & 2,5  & 3,5  & 4,5  & 5,5  & 6,5  & 7,5  \\
        \hline
        0,6  & 1,6  & 2,6  & 3,6  & 4,6  & 5,6  & 6,6  & 7,6  \\
        \hline
        0,7  & 1,7  & 2,7  & 3,7  & 4,7  & 5,7  & 6,7  & 7,7  \\
        \hline
    \end{tabular}
    \caption{This table represents the old indexing scheme used with a 2D array representing the board.}
    \label{tab:example_table}
\end{table} 

\begin{table}[H]
    \renewcommand{\arraystretch}{1.5}
    \setlength{\arrayrulewidth}{1pt}
    \setlength{\tabcolsep}{5pt}
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
        \hline
        0  & 1  & 2  & 3  & 4  & 5  & 6  & 7  \\
        \hline
        8  & 9  & 10  & 11  & 12  & 13  & 14  & 15  \\
        \hline
        16  & 17  & 18  & 19  & 20  & 21  & 22  & 23  \\
        \hline
        24  & 25  & 26  & 27  & 28  & 29  & 30  & 31  \\
        \hline
        32  & 33  & 34  & 35  & 36  & 37  & 38  & 39  \\
        \hline
        40  & 41  & 42  & 43  & 44  & 45  & 46  & 47  \\
        \hline
        48  & 49  & 50  & 51  & 52  & 53  & 54  & 55  \\
        \hline
        56  & 57  & 58  & 59  & 60  & 61  & 62  & 63  \\
        \hline
    \end{tabular}
    \caption{This table represents the new indexing scheme used with a 1D array representing the board.}
    \label{tab:example_table}
\end{table}

\subsection{Caching Board Evaluation}
When keep track of the evaluation of the board, the simplest scheme is to recompute the evaluation of the board each time it is needed.
We can obviously do better then this by just creating a variable on the board class to store the evaluation.
However since the evaluation only changes when a move happens we can change update the evaluation 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{recompute-eval-graph.png}
    \caption{The red bars represent the program where the board evaluation was recomputed each time during a depth search. The blue bars are when we cache and update the board evaluation}
    \label{fig:eval-speedup}
\end{figure}
\subsection{Parallelism}
The simplest way to parallelize the move search algorithm is at the top level.
Given a board state we can get all of the moves in that state we can then in parallel we can use the mini-max algorithm to those result in the best position for that player.
However this might not be the most optimal solution as Figure~\ref{fig:cpu-trace} shows.
This Figure~\ref{fig:cpu-trace} shows the CPU utilization over a run of iterative deepening looking for the best move.
The dips in CPU usage are when we are close to finishing a depth and start the next depth.
This happens because one of the branches of the search is taking longer to search. 
We were bottle necked by the slowest running move search.
\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\linewidth]{parallism-cpu.png}
    \caption{Shows the usage of the CPU over the course an execution of iterative deepening.}
    \label{fig:cpu-trace}
\end{figure}
We also do not always get the benefits of the parallelism.
For example if there are only a few moves at depth one you do not get the benefits of parallelism.

There is the additional complexity of using alpha beta pruning with parallelism.
There are also additional considerations with alpha beta pruning.

\subsection{Piece Singletons}
This is a very simple idea that greatly reduced the number of objects that we need to make.
The idea is that you do not need to make multiple instances of a Piece (eg. all of the white pawn in the entire program can point to the same Pawn object).
This greatly reduces the amount of time that we spent copying the board while branching.
Instead of allocating a new object we just need to copy the array of Piece references to the other board.
We can create all of the Piece class Singletons class.

Piece with this schema become just a collection of function.

 \subsection{Alpha Beta Pruning}
 Alpha-beta pruning is an optimization for the mini-max algorithm.
 It skips evaluating branches that will not affect the final optimal decision.
 It does this by using two values—alpha (best already explored path for the maximizer) and beta (best already explore path for the minimizer)—to "prune" unneeded branches.
 The following optimization rely on using the fact that we are using alpha beta pruning when we are looking for a move.

\subsubsection{Pseudo Move Generation}
This optimization relies on the benefits of alpha-b beta pruning.
The basic idea is that produce all of the valid move from any position is much more computationally expensive then generating a list of pseudo valid moves.
The moves are not valid in the sense that the computer is allowed to put it self in check.
This does not matter because during the mini-max algorithm the players would never chose to put them selves in check.
Furthermore those branches will be quickly pruned because of alpha beta pruning.

The reason that checking if a move puts the moving play in check is because it is implemented by copying the board preforming the move and check it the king is under attack.
This can be optimized by adding a conceptual  adding an undo move function.
Adding this function is not as simple at first glance it requires adding some extra board state like the piece that was taken last.
It also requires updating other castling and enpassent variables.

\subsubsection{Move Heuristic}


 
\begin{figure*}
    \centering
    \includegraphics[width=1.25\linewidth]{flamegraph-first.png}
    \caption{This is the flame graph produced running a 5 depth search from the start position. It show the unnecessary calls made in \texttt{Board.getChild()}}
    \label{fig:fist-flame}
\end{figure*}
\section{Results}
Depth 5 start position took 95 seconds.
After board copy constructor 58 seconds.

So far I have been able to reducer the execution time from the starting position from 93 seconds to 24 seconds for a 5 depth search.

\section{Appendix}

\begin{thebibliography}{9}
    \bibitem{jones} Peter Ellis Jones' Gist,  
        \url{https://gist.github.com/peterellisjones/8c46c28141c162d1d8a0f0badbc9cff9}
    
    \bibitem{pgn} PGN Mentor - Abdusattorov's Games,  
        \url{https://www.pgnmentor.com/players/Abdusattorov/}
        
    \bibitem{lichess-bot} lichess-bot,  
        \url{https://github.com/lichess-bot-devs/lichess-bot}
        
    \bibitem{uci} uci,  
        \url{https://www.chessprogramming.org/UCI}
    
    \bibitem{fen} fen,  
        \url{https://www.chessprogramming.org/Forsyth-Edwards_Notation}
        
    \bibitem{roce} ROCE - Roman's Own Chess Engine,  
        \url{http://www.rocechess.ch/rocee.html}
        
    \bibitem{parallel} Parallel Search,  
        \url{https://www.chessprogramming.org/Parallel_Search}
        
    \bibitem{stockfish} Stockfish,  
        \url{https://stockfishchess.org/}

    \bibitem{stockwiki} Stockfish Wikepidia,  
        \url{https://en.wikipedia.org/wiki/Stockfish_(chess)#Competition_results}
        
    \bibitem{bitboard} Bitboards,
        \url{https://www.chessprogramming.org/Bitboards}
        
\end{thebibliography}


\end{document}
